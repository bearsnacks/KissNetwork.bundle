#!/usr/bin/env python

"""Kiss(anime, cartoon, and drama) Service code"""

# import Shared Service Code
import kcore as KCore
import metadata as Metadata
from kheaders import Headers
from openload import OpenloadStreamFromURL
import https_fix as HTTPS
from io import open
import requests
import shutil

RE_URL_OL = Regex(r'src\=["\'](https?://(?:www\.)?o(?:pen)?load.+?)["\']')
#RE_URL_RV = Regex(r'src\=["\'](https?://(?:www\.)?rapidvideo\.[^"\']+?)["\']')
RE_URL_RV = Regex(r'(?:src\=["\']|\||^)(https?://(?:www\.)?rapidvideo\.[^"\'\|]+)["\']?')
RE_URL_SM = Regex(r'(?:src\=["\']|\||^)(https?://(?:www\.)?streamango\.[^"\'\|]+)["\']?')
RE_RV_NORM = Regex(r'(https?://(?:www\.)?\w+\.\w+)/e(?:mbed)?/(\w+)')
RE_ENC_TEST = Regex(r'/Scripts/((?:kissenc|oran|subo)(?:\.min)?\.j[^"\']+|vr\.j[^"\']+)')
RE_WINDOW1 = Regex(r'(?s)type\=["\']text/javascript["\']\>(.*?(window\[[^\=]+).*?)\</script\>')
RE_WINDOW2 = Regex(r'(.+window[^\=]+[^\;]+)')
RE_ITAG = Regex(r'itag\=(\d+)')
RE_ATOB = Regex(r'contents *?\= *?atob\(["\']([^"\']+)')
RE_SOURCES = Regex(r'(?i)["\']?sources["\']? *?(?:\:|\=) *?(\[.*?\{[^\]]+\}.*?\])')

########################################################################################
def MetadataObjectForURL(url):

    Log('*' * 80)
    Log(u'* MetadataObjectForURL url = {}'.format(url))
    url = KCore.util.correct_url(url)

    video_id = int(url.split('=')[-1])
    show_url = url.rsplit('/', 1)[0]

    html = KCore.network.ElementFromURL(show_url)

    genres, genres_list = Metadata.GetGenres(html)
    date_added = Metadata.GetDateAdded(html, url)
    thumb = Callback(get_thumb, url=show_url)
    art = Metadata.get_art(url)

    # Setup MovieObject for Moives
    if 'Movie' in genres:
        Log('* -----Movie-----')

        # remove 'Movie' from genre list
        genre_list = [g for g in genres if not g == 'Movie']
        mi = Metadata.GetBaseMovieInfo(html, url)
        summary = unicode(KCore.util.string_code(string=mi['summary'], code='decode')) if mi['summary'] else None

        return MovieObject(
            title=mi['title'],
            genres=genre_list,
            tags=Metadata.string_to_list(KCore.util.string_code(string=mi['tags'], code='decode')) if mi['tags'] else [],
            source_title=mi['source_title'],
            originally_available_at=date_added if date_added else None,
            year=int(mi['year']) if mi['year'] else None,
            countries=Metadata.string_to_list(KCore.util.string_code(string=mi['countries'], code='decode')) if mi['countries'] else [],
            thumb=thumb,
            art=art,
            summary=summary
            )
    # Setup EpisodeObject for all shows that are not Movies
    else:
        Log('* -----TV Show-----')

        si = Metadata.GetBaseShowInfo(html, url)
        summary = unicode(KCore.util.string_code(string=si['summary'], code='decode')) if si['summary'] else None
        tags = Metadata.string_to_list(KCore.util.string_code(string=si['tags'], code='decode')) if si['tags'] else []
        show_name_raw = html.xpath('//div[@class="barContent"]/div/a[@class="bigChar"]/text()')[0]
        start_title = Metadata.get_title(html, video_id, show_name_raw)
        season_number = Metadata.GetSeasonNumber(start_title, show_name_raw, tags, summary)
        ep_name, ep_number = Metadata.GetEpisodeNameAndNumber(html, start_title, url)
        new_title = Metadata.GetEpisodeTitle(int(season_number), ep_name, int(ep_number))

        return EpisodeObject(
            title=new_title,
            source_title=si['source_title'],
            show=si['tv_show_name'],
            season=int(season_number),
            index=int(ep_number),
            tags=tags,
            originally_available_at=date_added if date_added else None,
            thumb=thumb,
            art=art,
            summary=summary
            )

########################################################################################
@deferred
def MediaObjectsForURL(url):

    Log.Debug('*' * 80)
    fmt_list = [('1080', 'm37', 5000), ('720', 'm22', 2500), ('480', 'm59', 1125), ('360', 'm18', 650)]
    url = KCore.util.correct_url(url)

    if Prefs['server'] == 'Beta':
        Log.Debug("* Testing Beta Server")
        return [
            MediaObject(
                audio_channels=2,
                video_resolution=res,
                optimized_for_streaming=False,
                parts=[
                    PartObject(**PlayVideo(url, m))
                    ],
                ) for res, m, b in fmt_list if Prefs['beta_res'][:-1] == res
            ]
    elif Prefs['force_transcode']:
        Log.Debug('* Force Transcoding ON')
        return [
            MediaObject(
                audio_channels=2,
                video_resolution=res,
                optimized_for_streaming=False,
                parts=[
                    PartObject(key=Callback(PlayVideo, url=url, m=m))
                    ],
                ) for res, m, b in fmt_list
            ]
    else:
        Log.Debug('* Force Trascoding OFF')
        return [
            MediaObject(
                bitrate=b,
                video_resolution=res,
                container=Container.MP4,
                video_codec=VideoCodec.H264,
                audio_codec=AudioCodec.AAC,
                audio_channels=2,
                optimized_for_streaming=True,
                parts=[
                    PartObject(key=Callback(PlayVideo, url=url, m=m))
                    ],
                ) for res, m, b in fmt_list
            ]

########################################################################################
@indirect
def PlayVideo(url, m, **kwargs):
    """
    Get Video URL
    Currently available host: GoogleVideo, Openload
    GoogleVideo links have the potential for multiple resolutions links
    Stream.moe:
        - used to be supported, but host site is currently offline
        - leaving code for now as it does not affect playback
    Openload, and Stream.moe give only one link (the highest), so no optional resolutions

    Video URL fallback system.
    Order as follows:
    * Preferred Server = KissNetwork
        KissNetwork --> Beta --> Openload --> RapidVideo
    """

    Log.Debug('*' * 80)
    Log.Debug('* Client.Product     = {}'.format(Client.Product))
    Log.Debug('* Client.Platform    = {}'.format(Client.Platform))
    Log.Debug('* Client.Version     = {}'.format(Client.Version))
    Log.Debug('* Channel.Server1    = {}'.format(Prefs['server']))
    Log.Debug('* Channel.Server2    = {}'.format(Prefs['server2']))

    def setup_req_url(url, ser):
        if (ser == 'RapidVideo'):
            req_url = '{}&s=rapid{}'.format(url, '' if 'kissasian' in url else 'video')
        elif (ser != 'KissNetwork'):
            req_url = '{}&s={}'.format(url, ser.lower())
        else:
            req_url = url
        return req_url

    req_url = setup_req_url(url, Prefs['server'])
    vurl = get_video_url(url, m, KCore.network.Request(req_url))

    cs = Prefs['server']
    if (not vurl):
        cs = Prefs['server2']
        Log.Warn("* {} URL offline, falling back to {}".format(Prefs['server'], Prefs['server2']))
        #req_url = url + '&s={}'.format(Prefs['server2'].lower())
        req_url = setup_req_url(url, Prefs['server2'])
        vurl = get_video_url(url, m, KCore.network.Request(req_url))

    sl = set(['KissNetwork', 'Beta', 'RapidVideo', 'Openload', 'Streamango'])
    sp = set([Prefs['server'], Prefs['server2']])
    for s in (sl - sp):
        if (not vurl):
            Log.Warn("* {} URL offline, falling back to {}".format(cs, s))
            cs = s
            #req_url = url + '&s={}'.format(cs.lower())
            req_url = setup_req_url(url, cs)
            vurl = get_video_url(url, m, KCore.network.Request(req_url))

    Log.Debug('* PlayVideo URL      = {}'.format(vurl))

    if Prefs['force_redirect'] and (Prefs['force_transcode'] == False) and (Prefs['server'] == 'KissNetwork'):
        Log.Debug('* Force Redirect ON')
        Log.Debug('* Note: Videos will NO longer play outside the network connection.')
        try:
            vurl = get_url_redirect_v2(vurl)
            if 'googlevideo' in vurl and not vurl == False:
                Log.Debug('* URL Redirect       = {}'.format(vurl.split('?')[0] + '...'))
            else:
                Log.Debug('* URL Redirect       = {}'.format(vurl))
        except:
            Log.Exception('* URL Redirect faild. Returning PlayVideo URL instead')
    else:
        Log.Debug('* Force Redirect OFF')

    Log.Debug('*' * 80)

    if vurl:
        # TODO Fixed old open requests in Beta
        # TODO add cache time for beta cache
        if (Prefs['server'] == 'Beta') and (False):
            http_headers = {'User-Agent': KCore.core.user_agent, 'Referer': req_url}
            #t1 = KCore.network.init_stream(vurl)
            t1 = KCore.network.init_stream(url=vurl, headers=http_headers, init=True)
            Log("* beta.test[1] = {}".format(t1))
            if not t1[0]:
                KCore.network.init_stream(url=vurl, headers=http_headers, init=True)
            t2 = KCore.network.init_stream(vurl)
            Log("* beta.test[2] = {}".format(t2))
            if not t2[1]:
                raise Ex.MediaNotAvailable
            return {'key': t2[1], 'file': t2[1]}
            #return Redirect(t2[1])
            #return IndirectResponse(VideoClipObject, key=t2[0])
            #return {'key': t2[1], 'file': t2[1]}

            #return IndirectResponse(VideoClipObject, key=vurl, http_headers=http_headers)
            #test_file = KCore.storage.data_item_path(KCore.storage.join_path('DataTMP', 'test.mkv'))
            #Log("* test_file location = {}".format(test_file))
            #return IndirectResponse(VideoClipObject, key=test_file)
        return IndirectResponse(VideoClipObject, key=vurl)

    raise Ex.MediaNotAvailable

########################################################################################
def get_video_url(url, m, resp):
    if not resp:
        return False
    ol = RE_URL_OL.search(resp.text)
    rv = RE_URL_RV.search(resp.text)
    sm = RE_URL_SM.search(resp.text)
    sd = {'Openload': ol, 'RapidVideo': rv, 'Streamango': sm, 'KissNetwork': 0}

    sl = ['RapidVideo', 'Openload', 'Streamango', 'KissNetwork']
    sp = [s for s in [Prefs['server'], Prefs['server2']] if s != 'KissNetwork']
    for s in sp:
        si = sl.index(s)
        sl = sl[:si] + sl[si+1:]

    for n in (sp + sl):
        Log("* Testing for {} Video URL in {}".format(n, url))
        r = sd[n]
        if r:
            iurl = r.group(1)
            Log.Debug('* {} URL             = {}'.format(n, iurl))
            if (n == 'Openload'):
                return get_openload_url(iurl)
            elif (n == 'RapidVideo'):
                return get_rapidvideo_url(iurl, m)
            elif (n == 'Streamango'):
                return get_streamango_url(iurl, m)
        elif (r == 0):
            return get_googlevideo_url(url, m, resp)

    return False

####################################################################################################
def get_googlevideo_url(url, m, resp):
    """
    Get GoogleVideo URLs
    Returns the Hights stream playable depending on the previous Stream Selections
    If Stream not found, then try's to find next hightest.
    Example 1: format list = [1080p, 720p, 360p]
        If 480p was previously chosen, then 720p will be used
    Example 2: format list = [720p, 480p, 360p]
        If 1080p was previously chosen, then 720p will be used
    """

    page = resp.text
    headers = resp.headers
    page_url = resp.url
    html = HTML.ElementFromString(page)
    sQual = Regex(r'(id\="slcQualix")').search(page)
    olist = html.xpath('//select[@id="%s"]/option' %("slcQualix" if sQual else "selectQuality"))
    tt = KCore.util.get_tt(url)
    ttl = tt.lower()
    if not olist and (not page_url.endswith('openload')):
        Log.Error('* This Video is broken, Kiss{} is working to fix it.'.format(tt))
        #raise Ex.MediaNotAvailable
        return False

    vurl = False
    vurls = list()
    # format info taken from here:
    # https://github.com/rg3/youtube-dl/blob/fd050249afce1bcc9e7f4a127069375467007b55/youtube_dl/extractor/youtube.py#L281
    # mp4 {format: resolution} dictionary
    fmt_dict = {'37': 1080, '22': 720, '59': 480, '78': 480, '18': 360}
    if Prefs['force_transcode']:
        # When force transcoding, then provide support for webm and flv video resolutions
        # webm {format: resolution} dictionary
        fmt_dict.update({'43': 360, '44': 480, '45': 720, '46': 1080})
        # flv {format: resolution} dictionary
        fmt_dict.update({'35': 480, '34': 360})
    # reversed mp4 format dictionary, paired values with resolutin selection in MediaObjectsForURL()
    rfmt_dict = {'1080': 37, '720': 22, '480': 59, '360': 18}

    enc_test = RE_ENC_TEST.search(page)
    if enc_test:
        Log.Debug('* {}'.format(enc_test.group(1)))

    for node in olist:
        if enc_test:
            try:
                vurl_old = KCore.rks.decrypt(node.get('value'), url, headers)
            except Exception as e:
                Log.Error(u"* get_google_video[Error]: Cannot decrypt values in {} >>> {}".format(url, e))
                vurl_old = ['tmp']
        else:
            vurl_old = String.Base64Decode(node.get('value'))

        if ('googlevideo' in vurl_old) or ('blogspot.com' in vurl_old):
            try:
                itag = vurl_old.split('=m')[1]
                vurls.append((vurl_old, fmt_dict[itag]))
            except:
                itag = 'No itag Found!'
                itag_test = RE_ITAG.search(vurl_old)
                if itag_test:
                    itag = str(itag_test.group(1))
                    if itag in fmt_dict.keys():
                        vurls.append((vurl_old, fmt_dict[itag]))
        else:
            try:
                res = node.text.strip()[:-1]
                itag = str(rfmt_dict[res])
                vurls.append((vurl_old, int(res)))
            except Exception as e:
                itag = u'No itag Found: {}'.format(e)

        if not itag in fmt_dict.keys():
            Log.Warn('* Format NOT Supported: {}'.format(itag))

    if vurls:
        Log.Debug('* pre resolution selected = {}'.format(m))
        for item, mm in Util.ListSortedByKey(vurls, 1):
            vurl = item
            nm = rfmt_dict[str(mm)]
            if nm == int(m[1:]):
                #Log.Debug('* Selecting {}p stream'.format(mm))
                break
            elif mm > fmt_dict[m[1:]]:
                #Log.Debug('* Selecting {}p stream'.format(mm))
                break
        Log.Debug('* Selecting {}p stream'.format(mm))
    elif enc_test and page_url.endswith('openload'):
        olr = Regex(r'\$kissenc\.decrypt\(["\']([^"\']+)["\']').findall(page)
        vurl = get_openload_url(KCore.rks.decrypt(olr[0], url, headers)) if olr else False
    elif enc_test and ('rapid' in page_url.split('?')[-1]):
        rvr = Regex(r'\$kissenc\.decrypt\(["\']([^"\']+)["\']').findall(page)
        vurl = get_rapidvideo_url(KCore.rks.decrypt(rvr[0], m)) if rvr else False

    if ((ttl == 'cartoon') or (ttl == 'drama')) and ('Play?' in vurl):
        Log.Debug(u"* Trying to get {} Redirect Link for '{}'".format(ttl, vurl))
        headers['referer'] = url
        vurl = get_url_redirect_v2(vurl, headers)

    return vurl

####################################################################################################
def get_openload_url(url):
    """
    Get OpenLoad URLs
    Code returns stream link for OpenLoad videos
    """

    http_headers = {'User-Agent': KCore.core.user_agent, 'Referer': url}
    ourl = OpenloadStreamFromURL(url, http_headers=http_headers)
    if ourl:
        rourl = get_url_redirect_v2(ourl, http_headers)
        return rourl

    Log.Error(u"* OpenloadStreamFromURL: cannot parse for stream '{}'".format(url))
    return False

####################################################################################################
def get_rapidvideo_url(url, m):
    """Get RapidVideo.com URLs"""

    page = None
    try:
        page = HTTP.Request(url, cacheTime=CACHE_1MINUTE).content
    except Ex.URLError, e:
        if 'SSLError' in str(e.args):
            try:
                page = HTTPS.Request(url)
            except:
                Log.Exception("* RapidVideo Error[0]: for '{}' >>>".format(url))
    except:
        Log.Exception("* RapidVideo Error[1]: for '{}' >>>".format(url))

    if not page:
        return False

    rs = RE_SOURCES.search(page)
    if not rs:
        return False

    s = rs.group(1).replace("'", '"')
    sources = list()
    for src in JSON.ObjectFromString(s):
        src['res'] = int(src['res'][:-1] if src['res'].lower().endswith('p') else src['res'])
        if src['file'].startswith('/'):
            src['file'] = RE_RV_NORM.search(url).group(1) + src['file']
        sources.append({'file': src['file'], 'res': src['res']})

    fmt_dict = {'37': 1080, '22': 720, '59': 480, '18': 360}
    Log.Debug('* pre resolution selected = {}({})'.format(m, fmt_dict[m[1:]]))
    res = 0
    vurl = None
    for item in Util.ListSortedByKey(sources, 'res'):
        vurl = item['file']
        res = item['res']
        if res == fmt_dict[m[1:]]:
            break
        elif res > fmt_dict[m[1:]]:
            break
    Log.Debug('* Selecting {}p stream'.format(res))

    if not vurl:
        return False
    return vurl

####################################################################################################
def get_streamango_url(url, m):
    """Get Streamango.com URLs"""

    page = None
    try:
        page = HTTP.Request(url, cacheTime=CACHE_1MINUTE).content
    except Ex.URLError, e:
        if 'SSLError' in str(e.args):
            try:
                page = HTTPS.Request(url)
            except:
                Log.Exception("* Streamango Error[0]: for '{}' >>>".format(url))
    except:
        Log.Exception("* Streamango Error[1]: for '{}' >>>".format(url))

    if not page:
        return False

    sl = list()
    if Regex(r'(?i)s(?:ou)?rces *?\= *?(\[\])\;').search(page):
        for s in Regex(r'(?i)s(?:ou)?rces\.push\((\{[^\)]+)\)').findall(page):
            d = JSON.ObjectFromString(s)
            if d['type'] != 'video/mp4':
                continue
            if d['src'].startswith('//'):
                d['src'] = 'https:' + d['src']
            sl.append(d)
    if not sl:
        return False

    fmt_dict = {'37': 1080, '22': 720, '59': 480, '18': 360}
    Log.Debug('* pre resolution selected = {}({})'.format(m, fmt_dict[m[1:]]))
    res = 0
    vurl = None
    for item in Util.ListSortedByKey(sl, 'height'):
        vurl = item['src']
        res = item['height']
        if res == fmt_dict[m[1:]]:
            break
        elif res > fmt_dict[m[1:]]:
            break
    Log.Debug('* Selecting {}p stream'.format(res))
    if not vurl:
        return False
    return vurl

####################################################################################################
def get_url_redirect_v2(input_url, http_headers=None):
    """URL Redirect V2 using requests.head"""

    if not http_headers:
        http_headers = {'User-Agent': KCore.core.user_agent, 'Referer': input_url}

    r = requests.head(input_url, headers=http_headers)
    if 'location' in r.headers.keys():
        return r.headers['location']
    elif 'Location' in r.headers.keys():
        return r.headers['Location']

    Log.Debug(u"* URL Redirect: No Redirect URL for '{}'".format(input_url))
    Log.Debug(u'* URL Redirect: Headers = {}'.format(r.headers))
    return input_url

########################################################################################
def get_thumb(url):
    thumb = None
    html = KCore.network.ElementFromURL(url)
    cover_url = "na"
    tmp_curl = html.xpath('//head/link[@rel="image_src"]/@href')
    if tmp_curl:
        curl = tmp_curl[0] if tmp_curl[0].startswith('http') else KCore.util.get_base_url(url) + tmp_curl[0]
        cover_url = KCore.util.correct_cover_image(curl)

    if KCore.util.is_kiss_url(cover_url):
        cover_file = cover_url.rsplit('/')[-1]
        tt = KCore.util.get_tt(url)
        if KCore.storage.cover_exists(KCore.storage.join_path(tt, cover_file)):
            return KCore.storage.data_object(KCore.storage.Covers(KCore.storage.join_path(tt, cover_file)))

        type_dir = KCore.storage.data_item_path(KCore.storage.Covers(tt))
        KCore.storage.ensure_dirs(type_dir)
        path = KCore.storage.join_path(type_dir, cover_file)
        Log("* file save path '{}'".format(path))

        if not KCore.storage.file_exists(path):
            r = requests.get(cover_url, headers=Headers.get_headers_for_url(cover_url), stream=True)
            if r.status_code == 200:
                with open(path, 'wb') as f:
                    r.raw.decode_content = True
                    shutil.copyfileobj(r.raw, f)
                Log("* Successfully saved '{}' in DataCovers".format(cover_url))
            else:
                Log.Error("* Save file requests status '{}'".format(r.status_code))
        else:
            Log.Warn('* Cover file already exists, Skipped file save.')

        if KCore.storage.cover_exists(KCore.storage.join_path(tt, cover_file)):
            return KCore.storage.data_object(KCore.storage.Covers(KCore.storage.join_path(tt, cover_file)))

        Log.Error("* Issues loading '{}'".format(path))
    elif 'http' in cover_url:
        thumb = Redirect(cover_url)
    else:
        Log.Error('*' * 80)
        Log.Error('* cover url not a valid picture url | {}'.format(cover_url))
        Log.Error('*' * 80)

    return thumb